// Generated by CoffeeScript 1.4.0
(function() {
  var $, ConsoleReporter, Log, TestListener, TestRenderer, beforeEach, describe, env, expect, it, jasmine, _ref;

  $ = require('./vendor/jquery.fake.js').$;

  Log = require('./log.js').Log;

  _ref = require('./vendor/jasmine.js'), jasmine = _ref.jasmine, describe = _ref.describe, beforeEach = _ref.beforeEach, it = _ref.it, expect = _ref.expect;

  ConsoleReporter = require('./vendor/jasmine.reporter.js').ConsoleReporter;

  TestListener = function() {
    this.events = [];
    return this;
  };

  $.extend(TestListener.prototype, {
    notify: function(event) {
      this.events.push(Array.prototype.slice.call(arguments));
      return this[event];
    }
  });

  TestRenderer = function() {
    this.lines = [];
    return this;
  };

  TestRenderer.prototype = $.extend(new Log.Renderer, {
    insert: function(after, html) {
      var node;
      if (!html) {
        return;
      }
      if (after && (node = this.find(after))) {
        return Array.prototype.splice.apply(this.lines, [this.lines.indexOf(node) + 1, 0].concat(html.split("\n")));
      } else {
        return Array.prototype.splice.apply(this.lines, [0, 0].concat(html.split("\n")));
      }
    },
    remove: function(ids) {
      var id, line, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        id = ids[_i];
        line = this.find(id);
        if (line) {
          _results.push(this.lines.splice(this.lines.indexOf(line), 1));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    find: function(id) {
      var line, _i, _len, _ref1;
      _ref1 = this.lines;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        line = _ref1[_i];
        if (line.match(RegExp("id=\"" + id + "\""))) {
          return line;
        }
      }
    }
  });

  describe('Log', function() {
    beforeEach(function() {
      this.renderer = new TestRenderer;
      this.log = new Log;
      return this.log.listeners.push(this.renderer);
    });
    return describe('set', function() {
      it('reorders parts', function() {
        this.log.set(0, "foo\n\n");
        this.log.set(2, "buz\n");
        this.log.set(1, "bar\nbaz\n");
        return expect(this.renderer.lines.join("\n")).toBe('<p id="0-0"><a id=""></a>foo</p>\n<p id="0-1"><a id=""></a></p>\n<p id="1-0"><a id=""></a>bar</p>\n<p id="1-1"><a id=""></a>baz</p>\n<p id="2-0"><a id=""></a>buz</p>');
      });
      it('joins chunks that belong to the same line', function() {
        this.log.set(3, '...\nbar\n...');
        this.log.set(2, '...');
        this.log.set(0, "foo\n");
        this.log.set(1, '...');
        return expect(this.renderer.lines.join("\n")).toBe('<p id="0-0"><a id=""></a>foo</p>\n<p id="3-0"><a id=""></a>.........</p>\n<p id="3-1"><a id=""></a>bar</p>\n<p id="3-2"><a id=""></a>...</p>');
      });
      it('joins chunks (2)', function() {
        this.log.set(0, "a\n...");
        this.log.set(1, "...\nb");
        return expect(this.renderer.lines.join("\n")).toBe('<p id="0-0"><a id=""></a>a</p>\n<p id="1-0"><a id=""></a>......</p>\n<p id="1-1"><a id=""></a>b</p>');
      });
      it('works when tail starts with an \n-terminated line', function() {
        this.log.set(2, "...\n");
        this.log.set(1, '...');
        this.log.set(3, "b\n");
        return expect(this.renderer.lines.join("\n")).toBe('<p id="2-0"><a id=""></a>......</p>\n<p id="3-0"><a id=""></a>b</p>');
      });
      it('works when clearing a line followed by an \n-terminated line', function() {
        this.log.set(4, "b\n");
        this.log.set(1, "...");
        this.log.set(2, "\x1B[K\n");
        this.log.set(3, "a\n");
        return expect(this.renderer.lines.join("\n")).toBe('<p id="2-0" style="display: none;"><a id=""></a></p>\n<p id="3-0"><a id=""></a>a</p>\n<p id="4-0"><a id=""></a>b</p>');
      });
      it('works when concating lines followed by an \n-terminated line', function() {
        this.log.set(4, "b\n");
        this.log.set(1, "...");
        this.log.set(2, "...\n");
        this.log.set(3, "a\n");
        return expect(this.renderer.lines.join("\n")).toBe('<p id="2-0"><a id=""></a>......</p>\n<p id="3-0"><a id=""></a>a</p>\n<p id="4-0"><a id=""></a>b</p>');
      });
      return it('works with an intermediary empty string', function() {
        this.log.set(2, "b\n");
        this.log.set(0, "a\n");
        this.log.set(1, '');
        return expect(this.renderer.lines.join("\n")).toBe('<p id="0-0"><a id=""></a>a</p>\n<p id="2-0"><a id=""></a>b</p>');
      });
    });
  });

  describe('Log.Context', function() {
    beforeEach(function() {
      this.log = new Log("foo\n...");
      this.log.set(2, "...\nbuz");
      return this.listener = new TestListener;
    });
    return describe('insert', function() {
      it('triggers "remove" with the ids of the heading and tailing lines', function() {
        this.log.listeners.push(this.listener);
        this.log.set(1, '.');
        return expect(this.listener.events[0]).toEqual(['remove', ['0-1', '2-0']]);
      });
      return it('triggers "insert" with the generated html', function() {
        var event;
        this.log.listeners.push(this.listener);
        this.log.set(1, '.');
        event = this.listener.events[1];
        expect(event[0]).toBe('insert');
        expect(event[1]).toBe('0-0');
        return expect(event[2]).toEqual('<p id="2-0"><a id=""></a>.......</p>');
      });
    });
  });

  describe('Log.Part', function() {
    beforeEach(function() {
      return this.log = new Log("foo\nbar\n");
    });
    it('splits the given lines', function() {
      return expect(this.log.parts[0].lines.length).toBe(2);
    });
    describe('head', function() {
      it('is empty if the last line of previous part is a newline', function() {
        var tail;
        this.log.set(1, '...');
        tail = this.log.parts[0].head();
        return expect(tail.length).toBe(0);
      });
      return it('finds all preceeding lines that are not newlines', function() {
        var head;
        this.log.set(1, '...');
        this.log.set(2, "...\nbar");
        head = this.log.parts[2].head();
        expect(head.length).toBe(1);
        return expect(head[0].id).toBe('1-0');
      });
    });
    describe('tail', function() {
      it('is empty if there are no succeeding lines', function() {
        var tail;
        tail = this.log.parts[0].tail();
        return expect(tail.length).toBe(0);
      });
      return it('finds all succeeding lines up to the first newline (and including it)', function() {
        var tail;
        this.log.set(1, "foo\n...");
        this.log.set(2, "...");
        this.log.set(3, "...\n");
        tail = this.log.parts[1].tail();
        expect(tail.length).toBe(2);
        expect(tail[0].id).toBe('2-0');
        return expect(tail[1].id).toBe('3-0');
      });
    });
    describe('prev', function() {
      return it('finds the previous part, skipping over gaps', function() {
        this.log.set(2, 'baz');
        return expect(this.log.parts[2].prev().num).toBe(0);
      });
    });
    return describe('next', function() {
      return it('finds the next part, skipping over gaps', function() {
        this.log.set(2, 'baz');
        return expect(this.log.parts[0].next().num).toBe(2);
      });
    });
  });

  describe('Log.Line', function() {
    beforeEach(function() {
      this.log = new Log;
      this.log.set(0, "foo\nbar");
      return this.log.set(1, "baz\nbuz");
    });
    describe('prev', function() {
      it('returns the previous line from the same part if exists', function() {
        var line;
        line = this.log.parts[1].lines[1];
        return expect(line.prev().string).toBe("baz\n");
      });
      return it('returns the last line from the previous part if exists', function() {
        var line;
        line = this.log.parts[1].lines[0];
        return expect(line.prev().string).toBe('bar');
      });
    });
    return describe('next', function() {
      it('returns the next line from the same part if exists', function() {
        var line;
        line = this.log.parts[0].lines[0];
        return expect(line.next().string).toBe('bar');
      });
      return it('returns the first line from the next part if exists', function() {
        var line;
        line = this.log.parts[0].lines[1];
        return expect(line.next().string).toBe("baz\n");
      });
    });
  });

  env = jasmine.getEnv();

  env.addReporter(new ConsoleReporter(jasmine));

  env.execute();

}).call(this);
